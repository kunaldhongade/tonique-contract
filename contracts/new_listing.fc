#include "imports/stdlib.fc";

const op::lock_funds = "op::lock_funds"c;      ;; Lock funds for a specific period
const op::request_refund = "op::request_refund"c; ;; Request refund before expiry
const op::process_refund = "op::process_refund"c; ;; Process refund if requested
const op::deduct_funds = "op::deduct_funds"c;  ;; Deduct funds for restaurant payment

;; Storage variables
global int ctx_locked_balance;     ;; Locked TON balance
global int ctx_lock_expiry;        ;; Expiry timestamp
global int ctx_refund_requested;   ;; Refund status: 0 (no), 1 (requested)

;; Load persistent storage variables
() load_data() impure {
    var ds = get_data().begin_parse();

    ctx_locked_balance = ds~load_coins(); ;; Load locked TON balance
    ctx_lock_expiry = ds~load_uint(64);   ;; Load lock expiry time
    ctx_refund_requested = ds~load_uint(1); ;; Load refund status (0 or 1)

    ds.end_parse();
}

;; Save persistent storage variables
() save_data() impure {
    set_data(
        begin_cell()
            .store_coins(ctx_locked_balance)
            .store_uint(ctx_lock_expiry, 64)
            .store_uint(ctx_refund_requested, 1)
            .end_cell()
    );
}

;; Main function for receiving messages
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); } ;; Ignore empty messages

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { return (); } ;; Ignore bounced messages

    load_data(); ;; Load storage variables into memory

    int op = in_msg_body~load_uint(32); ;; Operation code (first 32 bits)
    int query_id = in_msg_body~load_uint(64); ;; Query ID (next 64 bits, optional)

    ;; Handle different operations
    if (op == op::lock_funds) {
        ;; Lock funds
        int lock_amount = in_msg_body~load_coins(); ;; Amount to lock
        int lock_period = in_msg_body~load_uint(32); ;; Period in seconds

        ctx_locked_balance += lock_amount; ;; Add to locked balance
        ctx_lock_expiry = now() + lock_period; ;; Set lock expiry
        ctx_refund_requested = 0; ;; Reset refund request status
        save_data(); ;; Persist changes
        return ();
    } if (op == op::request_refund) {
        ;; Request refund
        if (now() >= ctx_lock_expiry) { ;; If lock expired, auto-refund
            send_raw_message(
                begin_cell().store_coins(ctx_locked_balance).end_cell(),
                0
            );
            ctx_locked_balance = 0; ;; Reset locked balance
            ctx_refund_requested = 0; ;; Reset refund status
        } else {
            ctx_refund_requested = 1; ;; Mark refund as requested
        }
        save_data(); ;; Persist changes
        return ();
    } if (op == op::process_refund) {
        ;; Process refund if requested
        if (ctx_refund_requested == 1) {
            send_raw_message(
                begin_cell().store_coins(ctx_locked_balance).end_cell(),
                0
            );
            ctx_locked_balance = 0; ;; Reset locked balance
            ctx_refund_requested = 0; ;; Reset refund status
        }
        save_data(); ;; Persist changes
        return ();
    } if (op == op::deduct_funds) {
        ;; Deduct funds for restaurant payment
        int deduct_amount = in_msg_body~load_coins(); ;; Amount to deduct
        if (deduct_amount > ctx_locked_balance) {
            throw(0xff01); ;; Error: Insufficient balance
        }

        ctx_locked_balance -= deduct_amount; ;; Deduct amount from balance
        send_raw_message(
            begin_cell().store_coins(deduct_amount).end_cell(),
            0
        );
        save_data(); ;; Persist changes
        return ();
    }

    throw(0xffff); ;; Unknown operation
}

;; Getter methods for data retrieval
int get_locked_balance() method_id {
    load_data();
    return ctx_locked_balance;
}

int get_lock_expiry() method_id {
    load_data();
    return ctx_lock_expiry;
}

int is_refund_requested() method_id {
    load_data();
    return ctx_refund_requested;
}
